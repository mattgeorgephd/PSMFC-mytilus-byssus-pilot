qqline(test_me)
norm_test <- shapiro.test(test_me) # p-value fail = good, don't need transformation
print(norm_test$p.value)
# Normalize data if normality test failed
if(norm_test$p.value<0.05)     {
normalized <- bestNormalize(test_me)
test_me <- normalized$x.t # overwrite
qqnorm(test_me) # check linearity of transformed data
qqline(test_me)
print(shapiro.test(test_me))
print("transformed!",quote=FALSE)}
dat_stat$response <- test_me
# Run repeated measures anova using oyster ID has random effect
# https://www.r-bloggers.com/2015/08/two-way-anova-with-repeated-measures/
my_test <- aov(response ~ (trt * thread * pad), # Error(1|(factor(ID)/factor(trt))),
data = dat_stat)
my_test_summary <- summary(my_test)
summary(my_test)
# Significant interaction observed between timepoint:trt:ploidy. Proceed with HSD test.
tx <- with(dat_stat, interaction(trt))
amod <- aov(response ~ tx, data = dat_stat)
mult_comp <- HSD.test(amod, "tx", group=TRUE, console=TRUE)
#
# # save output
# write.table(my_test_summary$`Error: Within`[[1]], file = "stats/respirometry/AOV_respirometry.csv",      row.names = TRUE)
# write.table(mult_comp$groups,                     file = "stats/respirometry/HSD_test_respirometry.csv", row.names = TRUE)
# Define dataset for analysis, factors
dat_stat <- thread_plot
test_me  <- dat_stat$adhesion_kpa
dat_stat$ID         <- factor(dat_stat$mussel)
dat_stat$trt        <- factor(dat_stat$treatment)
dat_stat$thread     <- factor(dat_stat$thread)
dat_stat$pad        <- factor(dat_stat$pad_area)
# Test for normality
qqnorm(test_me) # check linearity of transformed data
qqline(test_me)
norm_test <- shapiro.test(test_me) # p-value fail = good, don't need transformation
print(norm_test$p.value)
# Normalize data if normality test failed
if(norm_test$p.value<0.05)     {
normalized <- bestNormalize(test_me)
test_me <- normalized$x.t # overwrite
qqnorm(test_me) # check linearity of transformed data
qqline(test_me)
print(shapiro.test(test_me))
print("transformed!",quote=FALSE)}
dat_stat$response <- test_me
# Run repeated measures anova using oyster ID has random effect
# https://www.r-bloggers.com/2015/08/two-way-anova-with-repeated-measures/
my_test <- aov(response ~ trt, # Error(1|(factor(ID)/factor(trt))),
data = dat_stat)
my_test_summary <- summary(my_test)
summary(my_test)
# Significant interaction observed between timepoint:trt:ploidy. Proceed with HSD test.
tx <- with(dat_stat, interaction(trt))
amod <- aov(response ~ tx, data = dat_stat)
mult_comp <- HSD.test(amod, "tx", group=TRUE, console=TRUE)
#
# # save output
# write.table(my_test_summary$`Error: Within`[[1]], file = "stats/respirometry/AOV_respirometry.csv",      row.names = TRUE)
# write.table(mult_comp$groups,                     file = "stats/respirometry/HSD_test_respirometry.csv", row.names = TRUE)
# Define dataset for analysis, factors
dat_stat <- thread_plot_all_mean
test_me  <- dat_stat$adhesion_kpa_mean
dat_stat$ID         <- factor(dat_stat$mussel)
dat_stat$trt        <- factor(dat_stat$treatment)
dat_stat$thread     <- factor(dat_stat$thread)
# Define dataset for analysis, factors
dat_stat <- thread_plot_all_mean
test_me  <- dat_stat$adhesion_kpa_mean
dat_stat$ID         <- factor(dat_stat$mussel)
dat_stat$trt        <- factor(dat_stat$treatment)
# dat_stat$thread     <- factor(dat_stat$thread)
# dat_stat$pad        <- factor(dat_stat$pad_area)
# Test for normality
qqnorm(test_me) # check linearity of transformed data
qqline(test_me)
norm_test <- shapiro.test(test_me) # p-value fail = good, don't need transformation
print(norm_test$p.value)
# Normalize data if normality test failed
if(norm_test$p.value<0.05)     {
normalized <- bestNormalize(test_me)
test_me <- normalized$x.t # overwrite
qqnorm(test_me) # check linearity of transformed data
qqline(test_me)
print(shapiro.test(test_me))
print("transformed!",quote=FALSE)}
dat_stat$response <- test_me
# Run repeated measures anova using oyster ID has random effect
# https://www.r-bloggers.com/2015/08/two-way-anova-with-repeated-measures/
my_test <- aov(response ~ trt, # Error(1|(factor(ID)/factor(trt))),
data = dat_stat)
my_test_summary <- summary(my_test)
summary(my_test)
# Significant interaction observed between timepoint:trt:ploidy. Proceed with HSD test.
tx <- with(dat_stat, interaction(trt))
amod <- aov(response ~ tx, data = dat_stat)
mult_comp <- HSD.test(amod, "tx", group=TRUE, console=TRUE)
#
# # save output
# write.table(my_test_summary$`Error: Within`[[1]], file = "stats/respirometry/AOV_respirometry.csv",      row.names = TRUE)
# write.table(mult_comp$groups,                     file = "stats/respirometry/HSD_test_respirometry.csv", row.names = TRUE)
# Define dataset for analysis, factors
dat_stat <- thread_plot_all_mean
test_me  <- dat_stat$adhesion_kpa_mean
dat_stat$ID         <- factor(dat_stat$mussel)
dat_stat$trt        <- factor(dat_stat$treatment)
# dat_stat$thread     <- factor(dat_stat$thread)
# dat_stat$pad        <- factor(dat_stat$pad_area)
# Test for normality
qqnorm(test_me) # check linearity of transformed data
qqline(test_me)
norm_test <- shapiro.test(test_me) # p-value fail = good, don't need transformation
print(norm_test$p.value)
# Normalize data if normality test failed
if(norm_test$p.value<0.05)     {
normalized <- bestNormalize(test_me)
test_me <- normalized$x.t # overwrite
qqnorm(test_me) # check linearity of transformed data
qqline(test_me)
print(shapiro.test(test_me))
print("transformed!",quote=FALSE)}
dat_stat$response <- test_me
# Run repeated measures anova using oyster ID has random effect
# https://www.r-bloggers.com/2015/08/two-way-anova-with-repeated-measures/
my_test <- aov(response ~ trt + Error(ID), # Error(1|(factor(ID)/factor(trt))),
data = dat_stat)
my_test_summary <- summary(my_test)
summary(my_test)
# Significant interaction observed between timepoint:trt:ploidy. Proceed with HSD test.
tx <- with(dat_stat, interaction(trt))
amod <- aov(response ~ tx, data = dat_stat)
mult_comp <- HSD.test(amod, "tx", group=TRUE, console=TRUE)
#
# # save output
# write.table(my_test_summary$`Error: Within`[[1]], file = "stats/respirometry/AOV_respirometry.csv",      row.names = TRUE)
# write.table(mult_comp$groups,                     file = "stats/respirometry/HSD_test_respirometry.csv", row.names = TRUE)
# Define dataset for analysis, factors
dat_stat <- thread_plot_all_repeated_mean
# Define dataset for analysis, factors
dat_stat <- thread_plot_repeated_mean
test_me  <- dat_stat$adhesion_kpa_mean
dat_stat$ID         <- factor(dat_stat$mussel)
dat_stat$trt        <- factor(dat_stat$treatment)
# dat_stat$thread     <- factor(dat_stat$thread)
# dat_stat$pad        <- factor(dat_stat$pad_area)
# Test for normality
qqnorm(test_me) # check linearity of transformed data
qqline(test_me)
norm_test <- shapiro.test(test_me) # p-value fail = good, don't need transformation
print(norm_test$p.value)
# Normalize data if normality test failed
if(norm_test$p.value<0.05)     {
normalized <- bestNormalize(test_me)
test_me <- normalized$x.t # overwrite
qqnorm(test_me) # check linearity of transformed data
qqline(test_me)
print(shapiro.test(test_me))
print("transformed!",quote=FALSE)}
dat_stat$response <- test_me
# Run repeated measures anova using oyster ID has random effect
# https://www.r-bloggers.com/2015/08/two-way-anova-with-repeated-measures/
my_test <- aov(response ~ trt + Error(ID), # Error(1|(factor(ID)/factor(trt))),
data = dat_stat)
my_test_summary <- summary(my_test)
summary(my_test)
# Significant interaction observed between timepoint:trt:ploidy. Proceed with HSD test.
tx <- with(dat_stat, interaction(trt))
amod <- aov(response ~ tx, data = dat_stat)
mult_comp <- HSD.test(amod, "tx", group=TRUE, console=TRUE)
#
# # save output
# write.table(my_test_summary$`Error: Within`[[1]], file = "stats/respirometry/AOV_respirometry.csv",      row.names = TRUE)
# write.table(mult_comp$groups,                     file = "stats/respirometry/HSD_test_respirometry.csv", row.names = TRUE)
getwd()
knitr::opts_chunk$set(echo = TRUE)
## RUN as part of "PSMFC-mytilus-byssus-pilot.Rproj"
## clear workspace
rm(list=ls())
## Load Packages
load.lib<-c("readxl","tidyverse","openxlsx") # List of required packages
install.lib <- load.lib[!load.lib %in% installed.packages()] # Select missing packages
for(lib in install.lib) install.packages(lib,dependencies=TRUE) # Install missing packages + dependencies
sapply(load.lib,require,character=TRUE) # Load all packages.
## Set ggplot theme
my_theme <- theme(line              = element_line(size=1.2),
rect              = element_rect(size=1.2),
text              = element_text(size=14,color="black"),
panel.background  = element_blank(),
panel.grid.major  = element_blank(),
panel.grid.minor  = element_blank(),
axis.text.x       = element_text(size=16,color="black"), #,angle=90),
axis.text.y       = element_text(size=16,color="black"),
axis.title.x      = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y      = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0)),
axis.ticks.x      = element_line(color="black"),
axis.ticks.y      = element_line(color="black"),
# axis.line         = element_line(color = "black", size = 0.1),
panel.border      = element_rect(color = "black", fill=NA, size=1.2),
legend.key        = element_blank(), # removes background of legend bullets
legend.position   = "none"
)
## RUN as part of "PSMFC-mytilus-byssus-pilot.Rproj"
## clear workspace
rm(list=ls())
## Load Packages
load.lib<-c("readxl","tidyverse","openxlsx") # List of required packages
install.lib <- load.lib[!load.lib %in% installed.packages()] # Select missing packages
for(lib in install.lib) install.packages(lib,dependencies=TRUE) # Install missing packages + dependencies
sapply(load.lib,require,character=TRUE) # Load all packages.
## Set ggplot theme
my_theme <- theme(line              = element_line(size=1.2),
rect              = element_rect(size=1.2),
text              = element_text(size=14,color="black"),
panel.background  = element_blank(),
panel.grid.major  = element_blank(),
panel.grid.minor  = element_blank(),
axis.text.x       = element_text(size=16,color="black"), #,angle=90),
axis.text.y       = element_text(size=16,color="black"),
axis.title.x      = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y      = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0)),
axis.ticks.x      = element_line(color="black"),
axis.ticks.y      = element_line(color="black"),
# axis.line         = element_line(color = "black", size = 0.1),
panel.border      = element_rect(color = "black", fill=NA, size=1.2),
legend.key        = element_blank(), # removes background of legend bullets
legend.position   = "none"
)
# extract data from all .txt files in a folder located at thread_strength/tensometer_output/control/ and add it to a nested list object
# the data has three column headers: Time, displacement, force.
# Add a third data column called "mussel" that is the first three characters of the file name.
# Set the working directory to the folder containing the txt files
setwd("thread_strength/tensometer_output/control/")
getwd()
setwd("/thread_strength/tensometer_output/control/")
setwd("thread_strength/tensometer_output/control")
getwd()
setwd(../..)
setwd("../..")
getwd()
setwd("..")
getwd()
# extract data from all .txt files in a folder located at thread_strength/tensometer_output/control/ and add it to a nested list object
# the data has three column headers: Time, displacement, force.
# Add a third data column called "mussel" that is the first three characters of the file name.
# Set the working directory to the folder containing the txt files
setwd("thread_strength/tensometer_output/control")
knitr::opts_chunk$set(echo = TRUE)
## RUN as part of "PSMFC-mytilus-byssus-pilot.Rproj"
## clear workspace
rm(list=ls())
## Load Packages
load.lib<-c("readxl","tidyverse","openxlsx") # List of required packages
install.lib <- load.lib[!load.lib %in% installed.packages()] # Select missing packages
for(lib in install.lib) install.packages(lib,dependencies=TRUE) # Install missing packages + dependencies
sapply(load.lib,require,character=TRUE) # Load all packages.
## Set ggplot theme
my_theme <- theme(line              = element_line(size=1.2),
rect              = element_rect(size=1.2),
text              = element_text(size=14,color="black"),
panel.background  = element_blank(),
panel.grid.major  = element_blank(),
panel.grid.minor  = element_blank(),
axis.text.x       = element_text(size=16,color="black"), #,angle=90),
axis.text.y       = element_text(size=16,color="black"),
axis.title.x      = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y      = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0)),
axis.ticks.x      = element_line(color="black"),
axis.ticks.y      = element_line(color="black"),
# axis.line         = element_line(color = "black", size = 0.1),
panel.border      = element_rect(color = "black", fill=NA, size=1.2),
legend.key        = element_blank(), # removes background of legend bullets
legend.position   = "none"
)
# extract data from all .txt files in a folder located at thread_strength/tensometer_output/control/ and add it to a nested list object
# the data has three column headers: Time, displacement, force.
# Add a third data column called "mussel" that is the first three characters of the file name.
# Set the working directory to the folder containing the txt files
setwd("thread_strength/tensometer_output/control")
# extract data from all .txt files in a folder located at thread_strength/tensometer_output/control/ and add it to a nested list object
# the data has three column headers: Time, displacement, force.
# Add a third data column called "mussel" that is the first three characters of the file name.
# Set the working directory to the folder containing the txt files
setwd("/thread_strength/tensometer_output/control")
# extract data from all .txt files in a folder located at thread_strength/tensometer_output/control/ and add it to a nested list object
# the data has three column headers: Time, displacement, force.
# Add a third data column called "mussel" that is the first three characters of the file name.
getwd()
# Set the working directory to the folder containing the txt files
setwd("/thread_strength/tensometer_output/control")
knitr::opts_chunk$set(echo = TRUE)
## RUN as part of "PSMFC-mytilus-byssus-pilot.Rproj"
## clear workspace
rm(list=ls())
## Load Packages
load.lib<-c("readxl","tidyverse","openxlsx") # List of required packages
install.lib <- load.lib[!load.lib %in% installed.packages()] # Select missing packages
for(lib in install.lib) install.packages(lib,dependencies=TRUE) # Install missing packages + dependencies
sapply(load.lib,require,character=TRUE) # Load all packages.
## Set ggplot theme
my_theme <- theme(line              = element_line(size=1.2),
rect              = element_rect(size=1.2),
text              = element_text(size=14,color="black"),
panel.background  = element_blank(),
panel.grid.major  = element_blank(),
panel.grid.minor  = element_blank(),
axis.text.x       = element_text(size=16,color="black"), #,angle=90),
axis.text.y       = element_text(size=16,color="black"),
axis.title.x      = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y      = element_text(margin = margin(t = 0, r = 10, b = 0, l = 0)),
axis.ticks.x      = element_line(color="black"),
axis.ticks.y      = element_line(color="black"),
# axis.line         = element_line(color = "black", size = 0.1),
panel.border      = element_rect(color = "black", fill=NA, size=1.2),
legend.key        = element_blank(), # removes background of legend bullets
legend.position   = "none"
)
# extract data from all .txt files in a folder located at thread_strength/tensometer_output/control/ and add it to a nested list object
# the data has three column headers: Time, displacement, force.
# Add a third data column called "mussel" that is the first three characters of the file name.
getwd()
# Set the working directory to the folder containing the txt files
setwd("/thread_strength/tensometer_output/control")
# extract data from all .txt files in a folder located at thread_strength/tensometer_output/control/ and add it to a nested list object
# the data has three column headers: Time, displacement, force.
# Add a third data column called "mussel" that is the first three characters of the file name.
getwd()
# Set the working directory to the folder containing the txt files
setwd("/thread_strength/tensometer_output/control/")
# extract data from all .txt files in a folder located at thread_strength/tensometer_output/control/ and add it to a nested list object
# the data has three column headers: Time, displacement, force.
# Add a third data column called "mussel" that is the first three characters of the file name.
getwd()
# Set the working directory to the folder containing the txt files
setwd("thread_strength/tensometer_output/control/")
# Create an empty list to hold the data
nested_list <- list()
# Get a vector of the names of all the txt files in the directory
txt_files <- list.files(pattern = "\\.txt$")
# Loop through each txt file, extract the data, and add it to the nested list
for (file_name in txt_files) {
# Read in the data from the txt file
data <- read.delim(file_name,
header = FALSE,
sep = "\t", # how is the data separated?
dec = ".")
# transpose
data_transpose = t(data)
# Snip data, Fix headers
data_snipped <- as.data.frame(data_transpose[,2:4]) # keep all rows, grab only column 2 through 4
colnames(data_snipped) <- c('time', 'displacement', 'force')
# Fix column data types
data_snipped$time         <- as.numeric(data_snipped$time)
data_snipped$displacement <- as.numeric(data_snipped$displacement)
data_snipped$force        <- as.numeric(data_snipped$force)
# Fix NA
data_snipped$time[is.na(data_snipped$time)] <- 0
data_snipped$displacement[is.na(data_snipped$displacement)] <- 0
data_snipped$force[is.na(data_snipped$force)] <- 0
# Add a new column called "mussel" that contains the first three characters of the file name
data_snipped$mussel <- substr(file_name, start = 1, stop = 3)
# Add new column that adds thread run
data_snipped$thread <- substr(file_name, start = 5, stop = 6)
# Add the data to the nested list using the file name as the list name
nested_list[[file_name]] <- data_snipped
}
str_split(file_name, "_")
split_1 <- str_split(file_name, "_")
split_1
split_2 <- str_split(split_1[2], "_")
split_1[[2]]
split_1[[1]]
split_1[[1]][[2]]
split_2 <- str_split(split_1[[1]][[2]], ".")
split_2
split_2 <- split_1[[1]][[2]]
split_3 <- str_split(split_2, ".")
split_3 <- str_split(split_2, "\\.")
data_snipped$mussel <- split_1[[1]][[1]]
data_snipped$thread <- split_3[[1]][[1]]
View(nested_list)
# extract data from all .txt files in a folder located at thread_strength/tensometer_output/control/ and add it to a nested list object
# the data has three column headers: Time, displacement, force.
# Add a third data column called "mussel" that is the first three characters of the file name.
getwd()
# Set the working directory to the folder containing the txt files
setwd("thread_strength/tensometer_output/control/")
# Create an empty list to hold the data
nested_list <- list()
# Get a vector of the names of all the txt files in the directory
txt_files <- list.files(pattern = "\\.txt$")
# Loop through each txt file, extract the data, and add it to the nested list
for (file_name in txt_files) {
# Read in the data from the txt file
data <- read.delim(file_name,
header = FALSE,
sep = "\t", # how is the data separated?
dec = ".")
# transpose
data_transpose = t(data)
# Snip data, Fix headers
data_snipped <- as.data.frame(data_transpose[,2:4]) # keep all rows, grab only column 2 through 4
colnames(data_snipped) <- c('time', 'displacement', 'force')
# Fix column data types
data_snipped$time         <- as.numeric(data_snipped$time)
data_snipped$displacement <- as.numeric(data_snipped$displacement)
data_snipped$force        <- as.numeric(data_snipped$force)
# Fix NA
data_snipped$time[is.na(data_snipped$time)] <- 0
data_snipped$displacement[is.na(data_snipped$displacement)] <- 0
data_snipped$force[is.na(data_snipped$force)] <- 0
# Extract mussel ID & thread test
split_1 <- str_split(file_name, "_") # Split file name by _
split_2 <- split_1[[1]][[2]] # Save thread test & .txt
split_3 <- str_split(split_2, "\\.") # Split thread test and .txt
data_snipped$mussel <- split_1[[1]][[1]] # Saving mussel ID
data_snipped$thread <- split_3[[1]][[1]] # Saving thread number
# Add the data to the nested list using the file name as the list name
nested_list[[file_name]] <- data_snipped
}
# Loop through the list object "nested_list"
# calculate the maximum value from the "force" column
# Save the maximum into a dataframe, along with the first values in the "mussel" column and "thread" column
# create a data frame with three columns: mussel, thread, and max_force
max_force_control <- data.frame(mussel = numeric(),
thread = numeric(),
max_force = numeric())
# loop through the nested list
for(i in seq_along(nested_list)){
# create a data frame for each list in the nested list
current_df <- nested_list[[i]]
# add a row to the max_force data frame with the mussel, thread, and max_force
max_force_control <- rbind(max_force_control, data.frame(mussel = current_df$mussel[1],
thread = current_df$thread[1],
max_force = max(current_df$force)))
}
require(stats)
# Loop through the list object "nested_list"
# extract the "time" and "force" column
# remove rows that contain zeros before first non-zero row. Apply to time column as well.
# remove rows that contain zeros after last non-zero row. Apply to time column as well.
# fit loess function to "time" and "force" after trimmed. Time is x, force is y.
# calculate area under the curve and save in dataframe, along with the first values in the "mussel" column and "thread" column from "nested_list"
# use a for loop to iterate through the nested list object "nested_list"
# Set the working directory to the folder containing the txt files
setwd("thread_strength/QC_plots/control/")
# create a data frame with three columns: mussel, thread, and max_force
integral <- data.frame(mussel = numeric(),
thread = numeric(),
auc = numeric())
for(i in seq_along(nested_list)){
# extract time and force column from the current nested list element using $ notation
current_df <- nested_list[[i]][c("time", "force")]
# fit loess function to "time" and "force" using loess() and save as an object
current_loess <- loess(force ~ time, data = current_df)
# plot the loess function with the corresponding time and force data points
jpeg(paste(nested_list[[i]]$mussel[1],"_",nested_list[[i]]$thread[1],".jpg",sep=""))
plot(current_df$time, current_df$force, main= "Force over Time Plot with Loess Function",
xlab = "Time", ylab = "Force", col = "blue")
lines(current_loess, col = "red") # add the loess function to the plot in red
dev.off()
# calculate area under the curve using approx() to approximate the integral and save to a variable
auc <- sum(diff(current_loess$x) * (approx(current_loess$x, current_loess$y, n = length(current_loess$x)))$y[-1])
# save the first values in the "mussel" and "thread" columns to variables
mussel_first_val <- nested_list[[i]]$mussel[1]
thread_first_val <- nested_list[[i]]$thread[1]
# create a dataframe to store the results, and save the variables to the corresponding columns in the dataframe
integral_control <- rbind(integral, data.frame(mussel = nested_list[[i]]$mussel[1],
thread = nested_list[[i]]$thread[1],
auc = auc))
}
require(stats)
# Loop through the list object "nested_list"
# extract the "time" and "force" column
# remove rows that contain zeros before first non-zero row. Apply to time column as well.
# remove rows that contain zeros after last non-zero row. Apply to time column as well.
# fit loess function to "time" and "force" after trimmed. Time is x, force is y.
# calculate area under the curve and save in dataframe, along with the first values in the "mussel" column and "thread" column from "nested_list"
# use a for loop to iterate through the nested list object "nested_list"
# Set the working directory to the folder containing the txt files
setwd("thread_strength/QC_plots/control/")
# create a data frame with three columns: mussel, thread, and max_force
integral_control <- data.frame(mussel = numeric(),
thread = numeric(),
auc = numeric())
for(i in seq_along(nested_list)){
# extract time and force column from the current nested list element using $ notation
current_df <- nested_list[[i]][c("time", "force")]
# fit loess function to "time" and "force" using loess() and save as an object
current_loess <- loess(force ~ time, data = current_df)
# plot the loess function with the corresponding time and force data points
jpeg(paste(nested_list[[i]]$mussel[1],"_",nested_list[[i]]$thread[1],".jpg",sep=""))
plot(current_df$time, current_df$force, main= "Force over Time Plot with Loess Function",
xlab = "Time", ylab = "Force", col = "blue")
lines(current_loess, col = "red") # add the loess function to the plot in red
dev.off()
# calculate area under the curve using approx() to approximate the integral and save to a variable
auc <- sum(diff(current_loess$x) * (approx(current_loess$x, current_loess$y, n = length(current_loess$x)))$y[-1])
# save the first values in the "mussel" and "thread" columns to variables
mussel_first_val <- nested_list[[i]]$mussel[1]
thread_first_val <- nested_list[[i]]$thread[1]
# create a dataframe to store the results, and save the variables to the corresponding columns in the dataframe
integral_control <- rbind(integral_control, data.frame(mussel = nested_list[[i]]$mussel[1],
thread = nested_list[[i]]$thread[1],
auc = auc))
}
View(integral_control)
rm integral
rm(integral)
write.xlsx(max_force_control, file="thread_strength/summarized_data/max_force_control.xlsx", colNames = TRUE)
write.xlsx(integral_control, file="thread_strength/summarized_data/integral_control.xlsx", colNames = TRUE)
print("done")
